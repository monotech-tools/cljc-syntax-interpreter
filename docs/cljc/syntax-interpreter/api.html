<!DOCTYPE html>
<html><html><head><link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet"><style type="text/css">body{font-family:Montserrat;margin:0 0 0 560px;padding:60px 48px}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-container{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{font-size:13px;letter-spacing:.5px;line-height:18px;padding:3px 12px;white-space:inherit}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:24px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.color--basic{color:#303030}.color--primary{color:#0088cc}.color--secondary{color:#8800cc}.color--muted{color:#606060}.color--warning{color:#883300}.collapsible-wrapper{display:flex;flex-direction:column}.collapsible-button{cursor:pointer;font-weight:500;position:relative;user-select:none;width:fit-content}.collapsible-button:hover{color:#888}.collapsible-button::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;position:absolute;height:24px;right:-24px;top:0;width:24px}.collapsible-wrapper[data-expanded="true"] .collapsible-button::after{content:'▲'}.collapsible-wrapper .content-block--box{display:none}.collapsible-wrapper[data-expanded="true"] .content-block--box{display:block}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{font-size:12px;line-height:60px;padding:0 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{font-size:18px;font-weight:600;line-height:60px;text-transform:uppercase}#top-bar--author-name{font-size:12px}#top-bar--library-version{font-size:12px;line-height:18px;margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{color:#aa55bb;font-size:12px;letter-spacing:.8px;line-height:42px;padding:0 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{font-size:18px;font-weight:600;line-height:24px;margin-top:24px}#declarations{display:flex;flex-direction:column}.declaration--wrapper{padding-top:96px}.declaration--name{border-bottom:1px solid #e0e0e0;font-size:18px;font-weight:600;line-height:18px;padding-bottom:8px;margin-bottom:12px}.tutorial--wrapper{padding-top:96px}.tutorial--name{border-bottom:1px solid #e0e0e0;font-size:18px;font-weight:600;line-height:18px;padding-bottom:8px;margin-bottom:12px}.content-blocks{display:flex;flex-direction:column}.content-block--separator{height:12px}.content-block--label{display:flex;gap:4px;line-height:24px}.content-block--box{background-color:#fafafa;color:#333;line-height:16px;margin:0;padding:12px 8px}.content-block--preview-image{border:1px solid #dedede;display:block;max-height:480px;max-width:640px;min-height:48px;min-width:64px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.expanded==='true'){collapsible.dataset.expanded='false';}else{collapsible.dataset.expanded='true';}}</script></head><body><div id="primary-list"><div class="scroll-container"><div class="primary-list--container"><pre class="text--xs color--muted">Isomorphic namespaces</pre><a href="https://mt-devtools.github.io/cljc-syntax-interpreter/cljc/syntax-interpreter/api.html"><pre class="button color--primary button--active">syntax-interpreter.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-container"><div class="secondary-list--container"><pre class="text--xs color--muted">Tutorials</pre><a href="#how-to-use-a-metafunction"><pre class="button color--secondary">How to use a metafunction?</pre></a><a href="#how-to-use-the-interpreter"><pre class="button color--secondary">How to use the interpreter?</pre></a><a href="#provided-metafunctions"><pre class="button color--secondary">Provided metafunctions</pre></a></div><div class="secondary-list--container"><pre class="text--xs color--muted">Declarations</pre><a href="#clj-patterns"><pre class="button color--primary">CLJ-PATTERNS</pre></a><a href="#css-patterns"><pre class="button color--primary">CSS-PATTERNS</pre></a><a href="#with-options"><pre class="button color--primary">with-options</pre></a><a href="#interpreter"><pre class="button color--primary">interpreter</pre></a></div></div></div><div id="namespace-header"><pre id="namespace-header--title">syntax-interpreter.api</pre><pre class="text--xs color--muted">Isomorphic namespace</pre></div><div id="tutorials--wrapper"><div id="tutorials"><div class="tutorial--wrapper" id="how-to-use-the-interpreter"><pre class="text--xs color--muted">Tutorial</pre><pre class="tutorial--name color--secondary">How to use the interpreter?</pre><div class="content-blocks"><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">The <a class="inline-link color--primary" href="#interpreter">syntax-interpreter.api/interpreter</a> function applies  the given 'f' function at each cursor position<br>of the given 'n' string.</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">It provides a state of the actual position and a set of metafunctions for the applied function.</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter ; Processed string:<br>             "abcdef (ghijkl ())"<br><br>             ; Processing function:<br>             (fn [result state metafunctions]<br>                 (cond ((:tag-starts? metafunctions) :paren) (update result :paren-starts-at conj (:cursor state))<br>                       ((:tag-opens?  metafunctions) :paren) (update result :paren-opens-at  conj (:cursor state))<br>                       ((:tag-closes? metafunctions) :paren) (update result :paren-closes-at conj (:cursor state))<br>                       ((:tag-ends?   metafunctions) :paren) (update result :paren-ends-at   conj (:cursor state))<br>                       :return result))<br><br>             ; Initial output:<br>             {:paren-starts-at [] :paren-opens-at [] :paren-closes-at [] :paren-ends-at []}<br><br>             ; Processed tags:<br>             [[:paren #"\(" #"\)"]])<br>=&gt;<br>{:paren-starts-at [ 7 16]<br> :paren-opens-at  [ 8 17]<br> :paren-closes-at [17 18]<br> :paren-ends-at   [18 19]}</pre></div></div></div><div class="tutorial--wrapper" id="how-to-use-a-metafunction"><pre class="text--xs color--muted">Tutorial</pre><pre class="tutorial--name color--secondary">How to use a metafunction?</pre><div class="content-blocks"><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ {:keys [tag-opened?] :as metafunctions}]<br>                 ; A)<br>                 (tag-opened? :my-tag)<br>                 ; B)<br>                 ((:tag-opened? metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div></div></div><div class="tutorial--wrapper" id="provided-metafunctions"><pre class="text--xs color--muted">Tutorial</pre><pre class="tutorial--name color--secondary">Provided metafunctions</pre><div class="content-blocks"><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Ancestor / parent tag metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:ancestor-tags   metafunctions))<br>                 ((:depth           metafunctions))<br>                 ((:no-tags-opened? metafunctions))<br>                 ((:parent-tag      metafunctions))<br>                 ((:tag-ancestor?   metafunctions) :my-tag)<br>                 ((:tag-depth       metafunctions) :my-tag)<br>                 ((:tag-parent?     metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Interpreter metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:reading-any-closing-match? metafunctions))<br>                 ((:reading-any-opening-match? metafunctions))<br>                 ((:reading-any-match?         metafunctions)))<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Operator metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ; The "My metadata" string will be available in the actual state from the next cursor position.<br>                 ((:use-metadata metafunctions) "My metadata" "My result")<br>                 ; Immediatelly stops the interpreter at the actual cursor position.<br>                 ((:stop metafunctions) "My result")<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Tag boundary metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:closing-tag    metafunctions))<br>                 ((:ending-tag     metafunctions))<br>                 ((:opening-tag    metafunctions))<br>                 ((:starting-tag   metafunctions))<br>                 ((:tag-closed-at  metafunctions) :my-tag)<br>                 ((:tag-closed?    metafunctions) :my-tag)<br>                 ((:tag-closes?    metafunctions) :my-tag)<br>                 ((:tag-ends?      metafunctions) :my-tag)<br>                 ((:tag-opened-at  metafunctions) :my-tag)<br>                 ((:tag-opened?    metafunctions) :my-tag)<br>                 ((:tag-opens?     metafunctions) :my-tag)<br>                 ((:tag-started-at metafunctions) :my-tag)<br>                 ((:tag-started?   metafunctions) :my-tag)<br>                 ((:tag-starts?    metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Tag body / content metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-body    metafunctions) :my-tag)<br>                 ((:tag-content metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Tag history metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-left-count metafunctions) :my-tag)<br>                 ((:tag-met-count  metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="text--m color--default">Tag details metafunctions:</pre></div><div class="content-block--separator"></div><div class="content-block"><pre class="content-block--box text--s">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-details         metafunctions) :my-tag)<br>                 ((:tag-opening-pattern metafunctions) :my-tag)<br>                 ((:tag-closing-pattern metafunctions) :my-tag)<br>                 ((:tag-options         metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div></div></div></div></div><div id="declarations--wrapper"><div id="declarations"><div class="declaration--wrapper" id="with-options"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary">with-options</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Error</pre></div><pre class="text--m color--warning">{:type :error, :description :unresolved-pointer-error, :pointer :syntax-interpreter.interpreter.core.utils/with-options}</pre></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="with-options-source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;with-options-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(def with-options core.utils/with-options)</pre></div></div><div class="declaration--wrapper" id="clj-patterns"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary">CLJ-PATTERNS</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Strings and regex patterns can include escaped quote characters. Therefore, their<br>closing pattern must exclude escape characters that precede the closing quote character.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Constant</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">vectors in map</pre><pre class="text--xs color--muted"></pre></div><pre class="text--s color--muted">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(interpreter "..." (fn [_ _ _] ...) nil [(:boolean           CLJ-PATTERNS)<br>                                         (:comment           CLJ-PATTERNS)<br>                                         (:conditional-form  CLJ-PATTERNS)<br>                                         (:derefed-symbol    CLJ-PATTERNS)<br>                                         (:keyword           CLJ-PATTERNS)<br>                                         (:list              CLJ-PATTERNS)<br>                                         (:map               CLJ-PATTERNS)<br>                                         (:meta-map          CLJ-PATTERNS)<br>                                         (:meta-string       CLJ-PATTERNS)<br>                                         (:meta-symbol       CLJ-PATTERNS)<br>                                         (:regex-pattern     CLJ-PATTERNS)<br>                                         (:string            CLJ-PATTERNS)<br>                                         (:symbol            CLJ-PATTERNS)<br>                                         (:unresolved-symbol CLJ-PATTERNS)<br>                                         (:var               CLJ-PATTERNS)<br>                                         (:vector            CLJ-PATTERNS)])</pre></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="clj-patterns-source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;clj-patterns-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(def CLJ-PATTERNS<br>     {:symbol            [:symbol            #"[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"     {:pattern-limits {:lookahead 1}}]<br>      :meta-symbol       [:meta-symbol       #"\^[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :derefed-symbol    [:derefed-symbol    #"\@[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :unresolved-symbol [:unresolved-symbol #"\'[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :var               [:var               #"\#\'[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])" {:pattern-limits {:lookahead 1}}]<br>      :keyword           [:keyword           #"\:[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{1,}(?=[\s\[\]\(\)\{\}\"\@\~])"                                   {:pattern-limits {:lookahead 1}}]<br>      :meta-keyword      [:meta-keyword      #"\^\:[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{1,}(?=[\s\[\]\(\)\{\}\"\@\~])"                                 {:pattern-limits {:lookahead 1}}]<br>      :boolean           [:boolean           #"true|false(?=[\s\[\]\(\)\{\}\"\@\~])"                     {:pattern-limits {:match 5 :lookahead 1}}]<br>      :conditional-form  [:conditional-form  #"\#\?\(\:clj[s]{0,}" #"\)"                                 {:pattern-limits {:opening/match 8 :closing/match 1}}]<br>      :list              [:list              #"\("                 #"\)"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :map               [:map               #"\{"                 #"\}"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :meta-map          [:meta-map          #"\^\{"               #"\}"                                 {:pattern-limits {:opening/match 2 :closing/match 1}}]<br>      :vector            [:vector            #"\["                 #"\]"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :comment           [:comment           #";"                  #"\n"           {:accepted-children [] :pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :regex-pattern     [:regex-pattern     #"\#\""               #"(?<=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]<br>      :string            [:string            #"\""                 #"(?<=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 1 :closing/match 1 :closing/lookbehind 1}}]<br>      :meta-string       [:meta-string       #"\^\""               #"(?<=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]})</pre></div></div><div class="declaration--wrapper" id="css-patterns"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary">CSS-PATTERNS</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Constant</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">vectors in map</pre><pre class="text--xs color--muted"></pre></div><pre class="text--s color--muted">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(interpreter "..." (fn [_ _ _] ...) nil [(:class CSS-PATTERNS)<br>                                         (:id    CSS-PATTERNS)<br>                                         (:tag   CSS-PATTERNS)])</pre></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="css-patterns-source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;css-patterns-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(def CSS-PATTERNS<br>     {:class [:class #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])\.[a-zA-Z\d\_][a-zA-Z\d\_\-]{0,}(?<=[\s\{\[\*\~\>\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]<br>      :id    [:id    #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])\#[a-zA-Z\d\_][a-zA-Z\d\_\-]{0,}(?<=[\s\{\[\*\~\>\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]<br>      :tag   [:tag   #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])[a-zA-Z]{1,}(?<=[\s\{\[\*\~\>\:\.\#])"                     {:pattern-limits {:lookbehind 1 :lookahead 1}}]})</pre></div></div><div class="declaration--wrapper" id="interpreter"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name color--primary">interpreter</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function at each cursor position of the given 'n' string.<br>- Provides a state of the actual position and a set of metafunctions for the applied function.<br>- The provided state contains the 'actual-tags' vector that describes the opened tags at the actual position<br>  and contains the 'left-tags' map that contains tags that are already ended before the actual position and<br>  removed from the 'actual-tags' vector.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">string</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div><pre class="text--s color--muted">Applied at each cursor position.<br>Takes the output of the previous iteration (or the given 'initial' value) as first parameter.<br>Takes the state of the actual cursor position as second parameter.<br>Takes a map with metafunctions as third parameter.</pre></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">initial</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">tags</pre><pre class="text--xs color--muted">vectors in vector</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">[[(keyword) tag-name<br>  (regex pattern) pattern / opening-pattern<br>  (regex pattern)(opt) closing-pattern<br>  (map)(opt) options<br>  {:accepted-ancestors (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted ancestor tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no ancestor tags.<br>   :accepted-children (keywords in vector or empty vector)(opt)<br>    Processes child tags only if listed in this vector.<br>    Leave this vector empty for void tags that cannot have children.<br>   :accepted-descendants (keywords in vector or empty vector)(opt)<br>    Processes descendant tags only if listed in this vector.<br>    Leave this vector empty for void tags that cannot have descendants.<br>   :accepted-parents (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted parent tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no parent tags.<br>   :pattern-limits (map)(opt)<br>    Limited pattern lookaround and match lengths help decrease the processing time<br>    and help create more accurate matches for tag patterns with lookaround assertions.<br>    {:lookahead (integer)(opt)<br>      Default: 0<br>     :lookbehind (integer)(opt)<br>      Default: 0<br>     :match (integer)(opt)<br>      Default: 64<br>     :closing/lookahead (integer)(opt)<br>      Default: 0<br>     :closing/lookbehind (integer)(opt)<br>      Default: 0<br>     :closing/match (integer)(opt)<br>      Default: 64<br>     :opening/lookahead (integer)(opt)<br>      Default: 0<br>     :opening/lookbehind (integer)(opt)<br>      Default: 0<br>     :opening/match (integer)(opt)<br>      Default: 64}]]</pre></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:endpoint (integer)(opt)<br>  Stops the interpreter at the given 'endpoint' position.<br> :offset (integer)(opt)<br>  Starts applying the given 'f' function at the given 'offset' position.<br>  In order to make accurate tag map, the interpreter starts processing at the 0th position even if the 'offset' value is higher than 0.}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(interpreter "My string" (fn [result state metafunctions]) nil)</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(interpreter "My string" println nil)</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(let [my-text     "abc(def(ghi))"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:paren #"\(" #"\)"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :paren :started-at 3 :opened-at 4}<br>               {:name :paren :started-at 7 :opened-at 8}]<br> :cursor 8}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="content-block--box text--s">(let [my-text     "&lt;div&gt;Hello World!&lt;/div&gt;"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:div #"\&lt;div\&gt;" #"\&lt;\/div\&gt;"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :div :started-at 0 :opened-at 5}]<br> :cursor 8}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="interpreter-source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;interpreter-source-code&apos;)">Source Code</pre><pre class="text-s content-block--box">(defn interpreter<br>  ([n f initial]<br>   (interpreter n f initial {} {}))<br><br>  ([n f initial tags]<br>   (interpreter n f initial tags {}))<br><br>  ([n f initial tags options]<br>   (letfn [<br>           (f0 [state]<br>               {:ancestor-tags              (interpreter.metafunctions/ancestor-tags-f             n tags options state)<br>                :closing-tag                (interpreter.metafunctions/closing-tag-f               n tags options state)<br>                :depth                      (interpreter.metafunctions/depth-f                     n tags options state)<br>                :ending-tag                 (interpreter.metafunctions/ending-tag-f                n tags options state)<br>                :left-sibling-count         (interpreter.metafunctions/left-sibling-count-f        n tags options state)<br>                :no-tags-opened?            (interpreter.metafunctions/no-tags-opened-f            n tags options state)<br>                :opening-tag                (interpreter.metafunctions/opening-tag-f               n tags options state)<br>                :parent-tag                 (interpreter.metafunctions/parent-tag-f                n tags options state)<br>                :reading-any-closing-match? (interpreter.metafunctions/reading-any-closing-match-f n tags options state)<br>                :reading-any-opening-match? (interpreter.metafunctions/reading-any-opening-match-f n tags options state)<br>                :reading-any-match?         (interpreter.metafunctions/reading-any-match-f         n tags options state)<br>                :starting-tag               (interpreter.metafunctions/starting-tag-f              n tags options state)<br>                :stop                       (interpreter.metafunctions/stop-f                      n tags options state)<br>                :tag-ancestor?              (interpreter.metafunctions/tag-ancestor-f              n tags options state)<br>                :tag-body                   (interpreter.metafunctions/tag-body-f                  n tags options state)<br>                :tag-closed-at              (interpreter.metafunctions/tag-closed-at-f             n tags options state)<br>                :tag-closed?                (interpreter.metafunctions/tag-closed-f                n tags options state)<br>                :tag-closes?                (interpreter.metafunctions/tag-closes-f                n tags options state)<br>                :tag-closing-pattern        (interpreter.metafunctions/tag-closing-pattern-f       n tags options state)<br>                :tag-content                (interpreter.metafunctions/tag-content-f               n tags options state)<br>                :tag-depth                  (interpreter.metafunctions/tag-depth-f                 n tags options state)<br>                :tag-details                (interpreter.metafunctions/tag-details-f               n tags options state)<br>                :tag-ends?                  (interpreter.metafunctions/tag-ends-f                  n tags options state)<br>                :tag-left-count             (interpreter.metafunctions/tag-left-count-f            n tags options state)<br>                :tag-met-count              (interpreter.metafunctions/tag-met-count-f             n tags options state)<br>                :tag-opened-at              (interpreter.metafunctions/tag-opened-at-f             n tags options state)<br>                :tag-opened?                (interpreter.metafunctions/tag-opened-f                n tags options state)<br>                :tag-opening-pattern        (interpreter.metafunctions/tag-opening-pattern-f       n tags options state)<br>                :tag-opens?                 (interpreter.metafunctions/tag-opens-f                 n tags options state)<br>                :tag-options                (interpreter.metafunctions/tag-options-f               n tags options state)<br>                :tag-parent?                (interpreter.metafunctions/tag-parent-f                n tags options state)<br>                :tag-started-at             (interpreter.metafunctions/tag-started-at-f            n tags options state)<br>                :tag-started?               (interpreter.metafunctions/tag-started-f               n tags options state)<br>                :tag-starts?                (interpreter.metafunctions/tag-starts-f                n tags options state)<br>                :use-metadata               (interpreter.metafunctions/use-metadata-f              n tags options state)})<br><br>           (f1 [state]<br>               (if (interpreter.utils/offset-reached? n tags options state)<br>                   (fn [result state metafunctions] (try (f result state metafunctions)<br>                                                         (catch Exception e (println e))))<br>                   (fn [result _ _] (-> result))))]<br><br>          (let [initial-state {:actual-tags [] :left-tags {} :cursor 0 :result initial}]<br>               (loop [{:keys [result] :as state} initial-state]<br>                     (let [actual-state           (interpreter.utils/update-previous-state n tags options state)<br>                           provided-state         (interpreter.utils/filter-provided-state n tags options actual-state)<br>                           provided-metafunctions (-> actual-state f0)<br>                           applied-function       (-> actual-state f1)<br>                           updated-result         (-> result (applied-function provided-state provided-metafunctions))<br>                           updated-state          (interpreter.utils/update-actual-state n tags options actual-state updated-result)]<br>                          (cond (interpreter.utils/iteration-stopped? n tags options updated-state) (-> updated-state :result)<br>                                (interpreter.utils/endpoint-reached?  n tags options updated-state) (-> updated-state :result)<br>                                (interpreter.utils/iteration-ended?   n tags options updated-state) (-> updated-state :result)<br>                                :next-iteration (let [prepared-state (interpreter.utils/prepare-next-state n tags options updated-state)]<br>                                                     (recur prepared-state)))))))))</pre></div></div></div></div><div id="top-bar"><pre id="top-bar--library-name">cljc-syntax-interpreter</pre><pre class="color--muted" id="top-bar--library-version">0.0.5.1</pre><a href="https://github.com/mt-devtools/cljc-syntax-interpreter" id="top-bar--library-uri"><pre class="color--primary">github.com/mt-devtools/cljc-syntax-interpreter</pre></a></div><div id="bottom-bar"><a href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>