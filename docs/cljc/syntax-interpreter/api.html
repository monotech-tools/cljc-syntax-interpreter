<!DOCTYPE html>
<html><html><head><link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet"><style type="text/css">body{font-family:Montserrat;margin:0 0 0 560px;padding:60px 48px}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-container{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{font-size:13px;letter-spacing:.5px;line-height:18px;padding:3px 12px;white-space:inherit}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:24px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.color--basic{color:#303030}.color--primary{color:#0088cc}.color--muted{color:#606060}.color--warning{color:#883300}.collapsible-wrapper{display:flex;flex-direction:column}.collapsible-button{cursor:pointer;font-weight:500;position:relative;user-select:none;width:fit-content}.collapsible-button:hover{color:#888}.collapsible-button::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;position:absolute;height:24px;right:-24px;top:0;width:24px}.collapsible-wrapper[data-expanded="true"] .collapsible-button::after{content:'▲'}.collapsible-wrapper .doc-block--box{display:none}.collapsible-wrapper[data-expanded="true"] .doc-block--box{display:block}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{font-size:12px;line-height:60px;padding:0 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{font-size:18px;font-weight:600;line-height:60px;text-transform:uppercase}#top-bar--author-name{font-size:12px}#top-bar--library-version{font-size:12px;line-height:18px;margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{color:#aa55bb;font-size:12px;letter-spacing:.8px;line-height:42px;padding:0 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{font-size:18px;font-weight:600;line-height:24px;margin-top:24px}#declarations{display:flex;flex-direction:column}.declaration--wrapper{padding-top:96px}.declaration--name{border-bottom:1px solid #e0e0e0;color:#558899;font-size:18px;font-weight:600;line-height:18px;padding-bottom:8px;margin-bottom:12px}.tutorial--wrapper{padding-top:96px}.tutorial--name{border-bottom:1px solid #e0e0e0;color:#665599;font-size:18px;font-weight:600;line-height:18px;padding-bottom:8px;margin-bottom:12px}.doc-blocks{display:flex;flex-direction:column}.doc-block--separator{height:12px}.doc-block--label{display:flex;gap:4px;line-height:24px}.doc-block--box{background-color:#fafafa;color:#333;line-height:16px;margin:0;padding:12px 8px}.doc-block--preview-image{border:1px solid #dedede;display:block;max-height:360px;max-width:640px;min-height:36px;min-width:48px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.expanded==='true'){collapsible.dataset.expanded='false';}else{collapsible.dataset.expanded='true';}}</script></head><body><div id="primary-list"><div class="scroll-container"><div class="primary-list--container"><pre class="text--xs color--muted">Isomorphic namespaces</pre><a href="https://mt-devtools.github.io/cljc-syntax-interpreter/cljc/syntax-interpreter/api.html"><pre class="button color--primary button--active">syntax-interpreter.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-container"><div class="secondary-list--container"><pre class="text--xs color--muted">Declarations</pre><a href="#CLJ-PATTERNS"><pre class="button color--primary">CLJ-PATTERNS</pre></a><a href="#CSS-PATTERNS"><pre class="button color--primary">CSS-PATTERNS</pre></a><a href="#interpreter"><pre class="button color--primary">interpreter</pre></a></div></div></div><div id="namespace-header"><pre id="namespace-header--title">syntax-interpreter.api</pre><pre class="text--xs color--muted">Isomorphic namespace</pre></div><div id="tutorials--wrapper"></div><div id="declarations--wrapper"><div id="declarations"><div class="declaration--wrapper" id="CLJ-PATTERNS"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name">CLJ-PATTERNS</pre><div class="doc-blocks"><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Strings and regex patterns can include escaped quote characters. Therefore, their<br>closing pattern must exclude escape characters that precede the closing quote character.</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Constant</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">vectors in map</pre><pre class="text--xs color--muted"></pre></div><pre class="text--s color--muted">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(interpreter "..." (fn [_ _ _] ...) nil [(:list   CLJ-PATTERNS)<br>                                         (:map    CLJ-PATTERNS)<br>                                         (:vector CLJ-PATTERNS)])</pre></div></div><div class="doc-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="CLJ-PATTERNS--source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;CLJ-PATTERNS--source-code&apos;)">Source Code</pre><pre class="text-s doc-block--box">(def CLJ-PATTERNS<br>     {:symbol            [:symbol            #"[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"     {:pattern-limits {:lookahead 1}}]<br>      :meta-symbol       [:meta-symbol       #"\^[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :derefed-symbol    [:derefed-symbol    #"\@[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :unresolved-symbol [:unresolved-symbol #"\'[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]<br>      :var               [:var               #"\#\'[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&][a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{0,}(?=[\s\[\]\(\)\{\}\"\@\~])" {:pattern-limits {:lookahead 1}}]<br>      :keyword           [:keyword           #"\:[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{1,}(?=[\s\[\]\(\)\{\}\"\@\~])"                                   {:pattern-limits {:lookahead 1}}]<br>      :meta-keyword      [:meta-keyword      #"\^\:[a-zA-Z\d\+\-\_\<\>\=\*\!\?\%\&\/\#\:\.\']{1,}(?=[\s\[\]\(\)\{\}\"\@\~])"                                 {:pattern-limits {:lookahead 1}}]<br>      :boolean           [:boolean           #"true|false(?=[\s\[\]\(\)\{\}\"\@\~])"                          {:pattern-limits {:match 5 :lookahead 1}}]<br>      :conditional-form  [:conditional-form  #"\#\?\(\:clj[s]{0,}" #"\)"                                      {:pattern-limits {:opening/match 8 :closing/match 1}}]<br>      :list              [:list              #"\("                 #"\)"                                      {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :map               [:map               #"\{"                 #"\}"                                      {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :meta-map          [:meta-map          #"\^\{"               #"\}"                                      {:pattern-limits {:opening/match 2 :closing/match 1}}]<br>      :vector            [:vector            #"\["                 #"\]"                                      {:pattern-limits {:opening/match 1 :closing/match 1}}]<br>      :comment           [:comment           #"<br>      :regex-pattern     [:regex-pattern     #"\#\""               #"(?<=[^\\])\"" {:disable-interpreter? true :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]<br>      :string            [:string            #"\""                 #"(?<=[^\\])\"" {:disable-interpreter? true :pattern-limits {:opening/match 1 :closing/match 1 :closing/lookbehind 1}}]<br>      :meta-string       [:meta-string       #"\^\""               #"(?<=[^\\])\"" {:disable-interpreter? true :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]})</pre></div></div><div class="declaration--wrapper" id="CSS-PATTERNS"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name">CSS-PATTERNS</pre><div class="doc-blocks"><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Note</pre></div><pre class="text--m color--muted">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Constant</pre><pre class="text-s color--default"></pre><pre class="text--xs color--muted">vectors in map</pre><pre class="text--xs color--muted"></pre></div><pre class="text--s color--muted">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(interpreter "..." (fn [_ _ _] ...) nil [(:class CSS-PATTERNS)<br>                                         (:id    CSS-PATTERNS)<br>                                         (:tag   CSS-PATTERNS)])</pre></div></div><div class="doc-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="CSS-PATTERNS--source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;CSS-PATTERNS--source-code&apos;)">Source Code</pre><pre class="text-s doc-block--box">(def CSS-PATTERNS<br>     {:class [:class #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])\.[a-zA-Z\d\_][a-zA-Z\d\_\-]{0,}(?<=[\s\{\[\*\~\>\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]<br>      :id    [:id    #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])\#[a-zA-Z\d\_][a-zA-Z\d\_\-]{0,}(?<=[\s\{\[\*\~\>\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]<br>      :tag   [:tag   #"(?<=[\s\}\]\)\*\~\>\+a-zA-Z\d\_\-])[a-zA-Z]{1,}(?<=[\s\{\[\*\~\>\:\.\#])"                     {:pattern-limits {:lookbehind 1 :lookahead 1}}]})</pre></div></div><div class="declaration--wrapper" id="interpreter"><pre class="text--xs color--muted">Declaration</pre><pre class="declaration--name">interpreter</pre><div class="doc-blocks"><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Description</pre></div><pre class="text--m color--basic">- Applies the given 'f' function at each cursor position of the given 'n' string.<br>- Provides a state of the actual position and a set of metafunctions for the applied function.<br>- The provided state contains the 'actual-tags' vector that describes the opened tags at the actual position<br>  and contains the 'left-tags' map that contains tags that are already ended before the actual position and<br>  removed from the 'actual-tags' vector.<br>- Available metafunctions within the applied 'f' function:<br>  Ancestor / parent tag metafunctions:<br>  - (ancestor-tags)<br>  - (depth)<br>  - (left-sibling-count)<br>  - (no-tags-opened?)<br>  - (parent-tag)<br>  - (tag-ancestor? :my-tag)<br>  - (tag-depth     :my-tag)<br>  - (tag-parent?   :my-tag)<br>  Interpreter metafunctions:<br>  - (interpreter-disabled-by)<br>  - (interpreter-disabled?)<br>  - (interpreter-enabled?)<br>  - (reading-any-closing-match?)<br>  - (reading-any-opening-match?)<br>  Operator metafunctions:<br>  - (use-metadata "My metadata" "My result")<br>  - (stop "My result")<br>  Tag boundary metafunctions:<br>  - (closing-tag)<br>  - (ending-tag)<br>  - (opening-tag)<br>  - (starting-tag)<br>  - (tag-closed-at  :my-tag)<br>  - (tag-closed?    :my-tag)<br>  - (tag-closes?    :my-tag)<br>  - (tag-ends?      :my-tag)<br>  - (tag-opened-at  :my-tag)<br>  - (tag-opened?    :my-tag)<br>  - (tag-opens?     :my-tag)<br>  - (tag-started-at :my-tag)<br>  - (tag-started?   :my-tag)<br>  - (tag-starts?    :my-tag)<br>  Tag body / content metafunctions:<br>  - (tag-body    :my-tag)<br>  - (tag-content :my-tag)<br>  Tag history metafunctions:<br>  - (tag-left-count :my-tag)<br>  - (tag-met-count  :my-tag)<br>  Tag details metafunctions:<br>  - (tag-details         :my-tag)<br>  - (tag-opening-pattern :my-tag)<br>  - (tag-closing-pattern :my-tag)<br>  - (tag-options         :my-tag)</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">n</pre><pre class="text--xs color--muted">string</pre><pre class="text--xs color--muted">required</pre></div></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">f</pre><pre class="text--xs color--muted">function</pre><pre class="text--xs color--muted">required</pre></div><pre class="text--s color--muted">Applied at each cursor position.<br>Takes the output of the previous iteration (or the given 'initial' value) as first parameter.<br>Takes the state of the actual cursor position as second parameter.<br>Takes a map with metafunctions as third parameter.</pre></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">initial</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted">required</pre></div></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">tags</pre><pre class="text--xs color--muted">vectors in vector</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">[[(keyword) tag-name<br>  (regex pattern) pattern / opening-pattern<br>  (regex pattern)(opt) closing-pattern<br>  (map)(opt) options<br>   {:accepted-ancestors (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted ancestor tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no ancestor tags.<br>   :accepted-parents (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted parent tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no parent tags.<br>   :disable-interpreter? (boolean)(opt)<br>    Disables processing of other tags whithin the tag (e.g., for comments, quotes, etc).<br>   :pattern-limits (map)(opt)<br>    Limited pattern lookaround and match lengths help decrease the processing time<br>    and help create more accurate matches for tag patterns with lookaround assertions.<br>    {:lookahead (integer)(opt)<br>      Default: 0<br>     :lookbehind (integer)(opt)<br>      Default: 0<br>     :match (integer)(opt)<br>      Default: 64<br>     :closing/lookahead (integer)(opt)<br>      Default: 0<br>     :closing/lookbehind (integer)(opt)<br>      Default: 0<br>     :closing/match (integer)(opt)<br>      Default: 64<br>     :opening/lookahead (integer)(opt)<br>      Default: 0<br>     :opening/lookbehind (integer)(opt)<br>      Default: 0<br>     :opening/match (integer)(opt)<br>      Default: 64}]]</pre></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Param</pre><pre class="text-s color--default">options</pre><pre class="text--xs color--muted">map</pre><pre class="text--xs color--muted">optional</pre></div><pre class="text--s color--muted">{:endpoint (integer)(opt)<br>  Stops the interpreter at the given 'endpoint' position.<br> :offset (integer)(opt)<br>  Starts applying the given 'f' function at the given 'offset' position.<br>  In order to make accurate tag map, the interpreter starts processing at the 0th position even if the 'offset' value is higher than 0.}</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(interpreter "My string" (fn [result state metafunctions]) nil)</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(interpreter "My string" println nil)</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(let [my-text     "abc(def(ghi))"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:paren #"\(" #"\)"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :paren :started-at 3 :opened-at 4}<br>               {:name :paren :started-at 7 :opened-at 8}]<br> :cursor 8}</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Usage</pre></div><pre class="doc-block--box text--s">(let [my-text     "&lt;div&gt;Hello World!&lt;/div&gt;"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:div #"\&lt;div\&gt;" #"\&lt;\/div\&gt;"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :div :started-at 0 :opened-at 5}]<br> :cursor 8}</pre></div><div class="doc-block--separator"></div><div class="doc-block"><div class="doc-block--label"><pre class="text--xs color--muted">Return</pre><pre class="text--xs color--muted">*</pre><pre class="text--xs color--muted"></pre></div></div></div><div class="doc-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="interpreter--source-code"><pre class="collapsible-button text--xs" onClick="toggleCollapsible(&apos;interpreter--source-code&apos;)">Source Code</pre><pre class="text-s doc-block--box">(defn interpreter<br>  ([n f initial]<br>   (interpreter n f initial {} {}))<br><br>  ([n f initial tags]<br>   (interpreter n f initial tags {}))<br><br>  ([n f initial tags options]<br>   (letfn [<br>           (f0 [state]<br>               {:ancestor-tags              (interpreter.metafunctions/ancestor-tags-f             n tags options state)<br>                :closing-tag                (interpreter.metafunctions/closing-tag-f               n tags options state)<br>                :depth                      (interpreter.metafunctions/depth-f                     n tags options state)<br>                :ending-tag                 (interpreter.metafunctions/ending-tag-f                n tags options state)<br>                :interpreter-disabled-by    (interpreter.metafunctions/interpreter-disabled-by-f   n tags options state)<br>                :interpreter-disabled?      (interpreter.metafunctions/interpreter-disabled-f      n tags options state)<br>                :interpreter-enabled?       (interpreter.metafunctions/interpreter-enabled-f       n tags options state)<br>                :left-sibling-count         (interpreter.metafunctions/left-sibling-count-f        n tags options state)<br>                :no-tags-opened?            (interpreter.metafunctions/no-tags-opened-f            n tags options state)<br>                :opening-tag                (interpreter.metafunctions/opening-tag-f               n tags options state)<br>                :parent-tag                 (interpreter.metafunctions/parent-tag-f                n tags options state)<br>                :reading-any-closing-match? (interpreter.metafunctions/reading-any-closing-match-f n tags options state)<br>                :reading-any-opening-match? (interpreter.metafunctions/reading-any-opening-match-f n tags options state)<br>                :starting-tag               (interpreter.metafunctions/starting-tag-f              n tags options state)<br>                :stop                       (interpreter.metafunctions/stop-f                      n tags options state)<br>                :tag-ancestor?              (interpreter.metafunctions/tag-ancestor-f              n tags options state)<br>                :tag-body                   (interpreter.metafunctions/tag-body-f                  n tags options state)<br>                :tag-closed-at              (interpreter.metafunctions/tag-closed-at-f             n tags options state)<br>                :tag-closed?                (interpreter.metafunctions/tag-closed-f                n tags options state)<br>                :tag-closes?                (interpreter.metafunctions/tag-closes-f                n tags options state)<br>                :tag-closing-pattern        (interpreter.metafunctions/tag-closing-pattern-f       n tags options state)<br>                :tag-content                (interpreter.metafunctions/tag-content-f               n tags options state)<br>                :tag-depth                  (interpreter.metafunctions/tag-depth-f                 n tags options state)<br>                :tag-details                (interpreter.metafunctions/tag-details-f               n tags options state)<br>                :tag-ends?                  (interpreter.metafunctions/tag-ends-f                  n tags options state)<br>                :tag-left-count             (interpreter.metafunctions/tag-left-count-f            n tags options state)<br>                :tag-met-count              (interpreter.metafunctions/tag-met-count-f             n tags options state)<br>                :tag-opened-at              (interpreter.metafunctions/tag-opened-at-f             n tags options state)<br>                :tag-opened?                (interpreter.metafunctions/tag-opened-f                n tags options state)<br>                :tag-opening-pattern        (interpreter.metafunctions/tag-opening-pattern-f       n tags options state)<br>                :tag-opens?                 (interpreter.metafunctions/tag-opens-f                 n tags options state)<br>                :tag-options                (interpreter.metafunctions/tag-options-f               n tags options state)<br>                :tag-parent?                (interpreter.metafunctions/tag-parent-f                n tags options state)<br>                :tag-started-at             (interpreter.metafunctions/tag-started-at-f            n tags options state)<br>                :tag-started?               (interpreter.metafunctions/tag-started-f               n tags options state)<br>                :tag-starts?                (interpreter.metafunctions/tag-starts-f                n tags options state)<br>                :use-metadata               (interpreter.metafunctions/use-metadata-f              n tags options state)})<br><br>           (f1 [state]<br>               (if (interpreter.utils/offset-reached? n tags options state)<br>                   (fn [result state metafunctions] (try (f result state metafunctions)<br>                                                         (catch Exception e (println e))))<br>                   (fn [result _ _] (-> result))))]<br><br>          (let [initial-state {:actual-tags [] :left-tags {} :cursor 0 :result initial}]<br>               (loop [{:keys [result] :as state} initial-state]<br><br>                     (let [actual-state           (interpreter.utils/update-previous-state n tags options state)<br>                           provided-state         (interpreter.utils/filter-provided-state n tags options actual-state)<br>                           provided-metafunctions (-> actual-state f0)<br>                           applied-function       (-> actual-state f1)<br>                           updated-result         (-> result (applied-function provided-state provided-metafunctions))<br>                           updated-state          (interpreter.utils/update-actual-state n tags options actual-state updated-result)]<br>                          (cond (interpreter.utils/iteration-stopped? n tags options updated-state) (-> updated-state :result)<br>                                (interpreter.utils/endpoint-reached?  n tags options updated-state) (-> updated-state :result)<br>                                (interpreter.utils/iteration-ended?   n tags options updated-state) (-> updated-state :result)<br>                                :next-iteration (let [prepared-state (interpreter.utils/prepare-next-state n tags options updated-state)]<br>                                                     (recur prepared-state)))))))))</pre></div></div></div></div><div id="top-bar"><pre id="top-bar--library-name">cljc-syntax-interpreter</pre><pre class="color--muted" id="top-bar--library-version">0.0.4.6</pre><a href="https://github.com/mt-devtools/cljc-syntax-interpreter" id="top-bar--library-uri"><pre class="color--primary">github.com/mt-devtools/cljc-syntax-interpreter</pre></a></div><div id="bottom-bar"><a href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>