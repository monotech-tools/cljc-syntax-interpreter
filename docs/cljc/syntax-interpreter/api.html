<!DOCTYPE html>
<html><html><head><style type="text/css">body{margin:0 0 0 560px;padding:60px 48px}button{background-color:transparent;border:none;cursor:pointer;padding:0;user-select:none}button:hover{opacity:.5}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-x{overflow-x:auto}.scroll-y{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{padding:3px 12px;white-space:inherit;letter-spacing:.5px}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:18px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.text--l{font-size:14px;line-height:18px}.text--xl{font-size:18px;line-height:24px}.text--semi-bold{font-weight:500}.text--bold{font-weight:600}.text--boxed{background-color:#fafafa;padding:12px 8px}.text--hidden{display:none}.text--wrap{-white-space:normal;white-space:pre-wrap}.color--hard-grey{color:#404040}.color--soft-grey{color:#808080}.color--hard-blue{color:#0088cc}.color--soft-blue{color:#55aabb}.color--hard-purple{color:#8800cc}.color--soft-purple{color:#aa55bb}.color--hard-red{color:#cc00aa}[data-collapsed="true"] .content-block--text{display:none}[data-collapsible="true"] .content-block--header::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;height:18px;width:18px}[data-collapsible="true"][data-collapsed="false"] .content-block--header::after{content:'▲'}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{padding:21px 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{padding:18px 0;text-transform:uppercase}#top-bar--library-version{margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{padding:12px 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{margin-top:24px}.section{padding-top:144px}.section--header{border-bottom:1px solid #e0e0e0;padding-bottom:8px;margin-bottom:12px}.content-blocks{display:flex;flex-direction:column;gap:24px}.content-block--header{display:flex;gap:4px}.content-block--preview-image{border:1px solid #dedede;display:block;max-height:480px;max-width:640px;min-height:48px;min-width:64px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.collapsed==='true'){collapsible.dataset.collapsed='false';}else{collapsible.dataset.collapsed='true';}}</script></head><body><div id="primary-list"><div class="scroll-y"><div class="primary-list--container"><pre class="color--soft-grey text--xs">Isomorphic namespaces</pre><a href="https://mt-devtools.github.io/cljc-syntax-interpreter/cljc/syntax-interpreter/api.html"><pre class="button color--hard-blue text--m button--active">syntax-interpreter.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-y"><div class="secondary-list--container"><pre class="color--soft-grey text--xs">Tutorials</pre><a href="#how-to-use-the-interpreter"><pre class="button color--hard-purple text--m">How to use the interpreter?</pre></a><a href="#how-to-use-metafunctions"><pre class="button color--hard-purple text--m">How to use metafunctions?</pre></a><a href="#provided-metafunctions"><pre class="button color--hard-purple text--m">Provided metafunctions</pre></a></div><div class="secondary-list--container"><pre class="text--xs color--soft-grey">Declarations</pre><a href="#clj-patterns"><pre class="button color--hard-blue text--m">CLJ-PATTERNS</pre></a><a href="#css-patterns"><pre class="button color--hard-blue text--m">CSS-PATTERNS</pre></a><a href="#with-options"><pre class="button color--hard-blue text--m">with-options</pre></a><a href="#interpreter"><pre class="button color--hard-blue text--m">interpreter</pre></a></div></div></div><div id="namespace-header"><pre class="text--xl text--bold" id="namespace-header--title">syntax-interpreter.api</pre><pre class="color--soft-grey text--xs">Isomorphic namespace</pre></div><div class="sections"><div class="section" id="how-to-use-the-interpreter"><div class="section--header"><pre class="color--soft-grey text--xs">tutorial</pre><pre class="color--hard-purple text--xl text--wrap text--bold">How to use the interpreter?</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="false" data-collapsible="false" id="q25ab287f-3f85-4855-b8c0-6977fc314abc"><div class="content-block--header"><pre class="text--hidden">plain</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">The <a class="inline-link color--hard-blue" href="#interpreter">syntax-interpreter.api/interpreter</a> function applies  the given 'f' function at each cursor position<br>of the given 'n' string.<br><br>It provides a state of the actual position and a set of metafunctions for the applied function.</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q075a9640-d6f3-4b46-a639-b1c9961c966c"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter ; Processed string:<br>             "abcdef (ghijkl ())"<br><br>             ; Processing function:<br>             (fn [result state metafunctions]<br>                 (cond ((:tag-starts? metafunctions) :paren) (update result :paren-starts-at conj (:cursor state))<br>                       ((:tag-opens?  metafunctions) :paren) (update result :paren-opens-at  conj (:cursor state))<br>                       ((:tag-closes? metafunctions) :paren) (update result :paren-closes-at conj (:cursor state))<br>                       ((:tag-ends?   metafunctions) :paren) (update result :paren-ends-at   conj (:cursor state))<br>                       :return result))<br><br>             ; Initial output:<br>             {:paren-starts-at [] :paren-opens-at [] :paren-closes-at [] :paren-ends-at []}<br><br>             ; Processed tags:<br>             [[:paren #"\(" #"\)"]])<br>=&gt;<br>{:paren-starts-at [ 7 16]<br> :paren-opens-at  [ 8 17]<br> :paren-closes-at [17 18]<br> :paren-ends-at   [18 19]}</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q93b5de2a-0158-407e-b66e-eaadecea8a0b"><div class="content-block--header"></div></div></div></div><div class="section" id="how-to-use-metafunctions"><div class="section--header"><pre class="color--soft-grey text--xs">tutorial</pre><pre class="color--hard-purple text--xl text--wrap text--bold">How to use metafunctions?</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="false" data-collapsible="false" id="q551dbd9f-1089-4bc8-81f6-5a834c50565c"><div class="content-block--header"><pre class="text--hidden">plain</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q98bf7e23-d9e7-444c-8ee0-40862ec71b0d"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ {:keys [tag-opened?] :as metafunctions}]<br>                 ; A)<br>                 (tag-opened? :my-tag)<br>                 ; B)<br>                 ((:tag-opened? metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q589fe9ae-cbbe-4627-bbcd-ed8995452976"><div class="content-block--header"></div></div></div></div><div class="section" id="provided-metafunctions"><div class="section--header"><pre class="color--soft-grey text--xs">tutorial</pre><pre class="color--hard-purple text--xl text--wrap text--bold">Provided metafunctions</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="false" data-collapsible="false" id="qf3547445-9e39-450f-83d8-2c24c2314f89"><div class="content-block--header"><pre class="text--hidden">plain</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">Ancestor / parent tag metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qaf4f90b1-66e1-4494-8c03-74a55dbca2ed"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:ancestor-tags   metafunctions))<br>                 ((:depth           metafunctions))<br>                 ((:no-tags-opened? metafunctions))<br>                 ((:parent-tag      metafunctions))<br>                 ((:tag-ancestor?   metafunctions) :my-tag)<br>                 ((:tag-depth       metafunctions) :my-tag)<br>                 ((:tag-parent?     metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])<br><br>Interpreter metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q9a09ad4e-6415-4182-9a94-56b13c8af053"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:reading-any-closing-match? metafunctions))<br>                 ((:reading-any-opening-match? metafunctions))<br>                 ((:reading-any-match?         metafunctions)))<br>             nil<br>             [[:my-tag #"..."]])<br><br>Operator metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q38442779-312a-4a30-aad6-f92e21df7a0c"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ; The "My metadata" string will be available in the actual state from the next cursor position.<br>                 ((:use-metadata metafunctions) "My metadata" "My result")<br>                 ; Immediatelly stops the interpreter at the actual cursor position.<br>                 ((:stop metafunctions) "My result")<br>             nil<br>             [[:my-tag #"..."]])<br><br>Tag boundary metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q841fdb08-a2e5-4257-b23c-727e553ff25c"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:closing-tag    metafunctions))<br>                 ((:ending-tag     metafunctions))<br>                 ((:opening-tag    metafunctions))<br>                 ((:starting-tag   metafunctions))<br>                 ((:tag-closed-at  metafunctions) :my-tag)<br>                 ((:tag-closed?    metafunctions) :my-tag)<br>                 ((:tag-closes?    metafunctions) :my-tag)<br>                 ((:tag-ends?      metafunctions) :my-tag)<br>                 ((:tag-opened-at  metafunctions) :my-tag)<br>                 ((:tag-opened?    metafunctions) :my-tag)<br>                 ((:tag-opens?     metafunctions) :my-tag)<br>                 ((:tag-started-at metafunctions) :my-tag)<br>                 ((:tag-started?   metafunctions) :my-tag)<br>                 ((:tag-starts?    metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])<br><br>Tag body / content metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qc7eafe8d-b832-4319-a23a-ffbeacc50501"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-body    metafunctions) :my-tag)<br>                 ((:tag-content metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])<br><br>Tag history metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qf3d25b5d-dac6-4892-a95c-ba65434f3dd1"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-left-count metafunctions) :my-tag)<br>                 ((:tag-met-count  metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])<br><br>Tag details metafunctions:</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qb69f25ad-c5e5-4bc6-874d-6c0eda14b8de"><div class="content-block--header"><pre class="color--soft-grey text--xs">code</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..."<br>             (fn [_ _ metafunctions]<br>                 ((:tag-details         metafunctions) :my-tag)<br>                 ((:tag-opening-pattern metafunctions) :my-tag)<br>                 ((:tag-closing-pattern metafunctions) :my-tag)<br>                 ((:tag-options         metafunctions) :my-tag))<br>             nil<br>             [[:my-tag #"..."]])</pre></div></div></div></div></div><div class="sections"><div class="section" id="with-options"><div class="section--header"><pre class="color--soft-grey text--xs">def</pre><pre class="color--hard-blue text--xl text--bold">with-options</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="true" data-collapsible="true" id="q412716c2-476c-4f1f-9395-e40ce0dab755"><button class="content-block--header" onClick="toggleCollapsible(&apos;q412716c2-476c-4f1f-9395-e40ce0dab755&apos;)"><pre class="color--hard-grey text--xs">source-code</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(def with-options core.utils/with-options)</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q31d38f16-c35a-460a-bef4-1e78f58e9d9b"><div class="content-block--header"><pre class="color--hard-red text--xs">error</pre></div></div></div></div><div class="section" id="clj-patterns"><div class="section--header"><pre class="color--soft-grey text--xs">def</pre><pre class="color--hard-blue text--xl text--bold">CLJ-PATTERNS</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="true" data-collapsible="true" id="q681ed34d-122b-4d1c-a11b-44ebc2133697"><button class="content-block--header" onClick="toggleCollapsible(&apos;q681ed34d-122b-4d1c-a11b-44ebc2133697&apos;)"><pre class="color--hard-grey text--xs">source-code</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(def CLJ-PATTERNS
     {:symbol            [:symbol            #"[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&][a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']*(?=[\s\[\]\(\)\{\}\"\@\~])"     {:pattern-limits {:lookahead 1}}]
      :meta-symbol       [:meta-symbol       #"\^[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&][a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']*(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]
      :derefed-symbol    [:derefed-symbol    #"\@[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&][a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']*(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]
      :unresolved-symbol [:unresolved-symbol #"\'[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&][a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']*(?=[\s\[\]\(\)\{\}\"\@\~])"   {:pattern-limits {:lookahead 1}}]
      :var               [:var               #"\#\'[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&][a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']*(?=[\s\[\]\(\)\{\}\"\@\~])" {:pattern-limits {:lookahead 1}}]
      :keyword           [:keyword           #"\:[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']+(?=[\s\[\]\(\)\{\}\"\@\~])"                                   {:pattern-limits {:lookahead 1}}]
      :meta-keyword      [:meta-keyword      #"\^\:[a-zA-Z\d\+\-\_\&lt;\&gt;\=\*\!\?\%\&\/\#\:\.\']+(?=[\s\[\]\(\)\{\}\"\@\~])"                                 {:pattern-limits {:lookahead 1}}]
      :boolean           [:boolean           #"true|false(?=[\s\[\]\(\)\{\}\"\@\~])"                     {:pattern-limits {:match 5 :lookahead 1}}]
      :conditional-form  [:conditional-form  #"\#\?\(\:clj[s]*" #"\)"                                    {:pattern-limits {:opening/match 8 :closing/match 1}}]
      :list              [:list              #"\("                 #"\)"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]
      :map               [:map               #"\{"                 #"\}"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]
      :meta-map          [:meta-map          #"\^\{"               #"\}"                                 {:pattern-limits {:opening/match 2 :closing/match 1}}]
      :vector            [:vector            #"\["                 #"\]"                                 {:pattern-limits {:opening/match 1 :closing/match 1}}]
      :comment           [:comment           #";"                  #"\n"           {:accepted-children [] :pattern-limits {:opening/match 1 :closing/match 1}}]
      :regex-pattern     [:regex-pattern     #"\#\""               #"(?&lt;=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]
      :string            [:string            #"\""                 #"(?&lt;=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 1 :closing/match 1 :closing/lookbehind 1}}]
      :meta-string       [:meta-string       #"\^\""               #"(?&lt;=[^\\])\"" {:accepted-children [] :pattern-limits {:opening/match 2 :closing/match 1 :closing/lookbehind 1}}]})</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q0ea1f9ea-f226-4b37-a8f2-64b5e57ae681"><div class="content-block--header"><pre class="color--hard-blue text--xs">note</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q63b52bb0-8e26-4945-a499-f077117ff2af"><div class="content-block--header"><pre class="color--hard-blue text--xs">note</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">Strings and regex patterns can include escaped quote characters. Therefore, their<br>closing pattern must exclude escape characters that precede the closing quote character.</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q5b34b111-193f-4db8-9fa2-b821140681ec"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..." (fn [_ _ _] ...) nil [(:boolean           CLJ-PATTERNS)<br>                                         (:comment           CLJ-PATTERNS)<br>                                         (:conditional-form  CLJ-PATTERNS)<br>                                         (:derefed-symbol    CLJ-PATTERNS)<br>                                         (:keyword           CLJ-PATTERNS)<br>                                         (:list              CLJ-PATTERNS)<br>                                         (:map               CLJ-PATTERNS)<br>                                         (:meta-map          CLJ-PATTERNS)<br>                                         (:meta-string       CLJ-PATTERNS)<br>                                         (:meta-symbol       CLJ-PATTERNS)<br>                                         (:regex-pattern     CLJ-PATTERNS)<br>                                         (:string            CLJ-PATTERNS)<br>                                         (:symbol            CLJ-PATTERNS)<br>                                         (:unresolved-symbol CLJ-PATTERNS)<br>                                         (:var               CLJ-PATTERNS)<br>                                         (:vector            CLJ-PATTERNS)])</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="true" id="q672f8e88-2eec-4514-8cca-803c047e69ce"><button class="content-block--header" onClick="toggleCollapsible(&apos;q672f8e88-2eec-4514-8cca-803c047e69ce&apos;)"><pre class="color--soft-grey text--xs">constant</pre><pre class="color--soft-grey text--xs">vectors in map</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div></div></div></div><div class="section" id="css-patterns"><div class="section--header"><pre class="color--soft-grey text--xs">def</pre><pre class="color--hard-blue text--xl text--bold">CSS-PATTERNS</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="true" data-collapsible="true" id="qe4be948d-faab-4918-b38d-203885d174d7"><button class="content-block--header" onClick="toggleCollapsible(&apos;qe4be948d-faab-4918-b38d-203885d174d7&apos;)"><pre class="color--hard-grey text--xs">source-code</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(def CSS-PATTERNS
     {:class [:class #"(?&lt;=[\s\}\]\)\*\~\&gt;\+a-zA-Z\d\_\-])\.[a-zA-Z\d\_][a-zA-Z\d\_\-]*(?&lt;=[\s\{\[\*\~\&gt;\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]
      :id    [:id    #"(?&lt;=[\s\}\]\)\*\~\&gt;\+a-zA-Z\d\_\-])\#[a-zA-Z\d\_][a-zA-Z\d\_\-]*(?&lt;=[\s\{\[\*\~\&gt;\:\.\#])" {:pattern-limits {:lookbehind 1 :lookahead 1}}]
      :tag   [:tag   #"(?&lt;=[\s\}\]\)\*\~\&gt;\+a-zA-Z\d\_\-])[a-zA-Z]+(?&lt;=[\s\{\[\*\~\&gt;\:\.\#])"                     {:pattern-limits {:lookbehind 1 :lookahead 1}}]})</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q8f3c5530-5a19-476e-88f2-42bd0a754882"><div class="content-block--header"><pre class="color--hard-blue text--xs">note</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">Lookbehind, lookahead and match length limits help decrease the processing time,<br>and help create more accurate matches for tag patterns with lookaround assertions.</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q329578aa-5217-46cc-84ff-15ae63a47b34"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "..." (fn [_ _ _] ...) nil [(:class CSS-PATTERNS)<br>                                         (:id    CSS-PATTERNS)<br>                                         (:tag   CSS-PATTERNS)])</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="true" id="q4e537436-a96c-4ad0-a273-45c613197817"><button class="content-block--header" onClick="toggleCollapsible(&apos;q4e537436-a96c-4ad0-a273-45c613197817&apos;)"><pre class="color--soft-grey text--xs">constant</pre><pre class="color--soft-grey text--xs">vectors in map</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">{:tag-name (vector)<br>  [(keyword) tag-name<br>   (regex pattern) pattern / opening-pattern<br>   (regex pattern)(opt) closing-pattern<br>   (map)(opt) options]}</pre></div></div></div></div><div class="section" id="interpreter"><div class="section--header"><pre class="color--soft-grey text--xs">defn</pre><pre class="color--hard-blue text--xl text--bold">interpreter</pre></div><div class="content-blocks"><div class="content-block" data-collapsed="true" data-collapsible="true" id="q68a1fac8-78ea-40fc-acc2-862f66de62b9"><button class="content-block--header" onClick="toggleCollapsible(&apos;q68a1fac8-78ea-40fc-acc2-862f66de62b9&apos;)"><pre class="color--hard-grey text--xs">source-code</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(defn interpreter
  ([n f initial]
   (interpreter n f initial {} {}))

  ([n f initial tags]
   (interpreter n f initial tags {}))

  ([n f initial tags options]
   (letfn [
           (f0 [state]
               {:ancestor-tags              (interpreter.metafunctions/ancestor-tags-f             n tags options state)
                :closing-tag                (interpreter.metafunctions/closing-tag-f               n tags options state)
                :depth                      (interpreter.metafunctions/depth-f                     n tags options state)
                :ending-tag                 (interpreter.metafunctions/ending-tag-f                n tags options state)
                :left-sibling-count         (interpreter.metafunctions/left-sibling-count-f        n tags options state)
                :no-tags-opened?            (interpreter.metafunctions/no-tags-opened-f            n tags options state)
                :opening-tag                (interpreter.metafunctions/opening-tag-f               n tags options state)
                :parent-tag                 (interpreter.metafunctions/parent-tag-f                n tags options state)
                :reading-any-closing-match? (interpreter.metafunctions/reading-any-closing-match-f n tags options state)
                :reading-any-opening-match? (interpreter.metafunctions/reading-any-opening-match-f n tags options state)
                :reading-any-match?         (interpreter.metafunctions/reading-any-match-f         n tags options state)
                :starting-tag               (interpreter.metafunctions/starting-tag-f              n tags options state)
                :stop                       (interpreter.metafunctions/stop-f                      n tags options state)
                :tag-ancestor?              (interpreter.metafunctions/tag-ancestor-f              n tags options state)
                :tag-body                   (interpreter.metafunctions/tag-body-f                  n tags options state)
                :tag-closed-at              (interpreter.metafunctions/tag-closed-at-f             n tags options state)
                :tag-closed?                (interpreter.metafunctions/tag-closed-f                n tags options state)
                :tag-closes?                (interpreter.metafunctions/tag-closes-f                n tags options state)
                :tag-closing-pattern        (interpreter.metafunctions/tag-closing-pattern-f       n tags options state)
                :tag-content                (interpreter.metafunctions/tag-content-f               n tags options state)
                :tag-depth                  (interpreter.metafunctions/tag-depth-f                 n tags options state)
                :tag-details                (interpreter.metafunctions/tag-details-f               n tags options state)
                :tag-ends?                  (interpreter.metafunctions/tag-ends-f                  n tags options state)
                :tag-left-count             (interpreter.metafunctions/tag-left-count-f            n tags options state)
                :tag-met-count              (interpreter.metafunctions/tag-met-count-f             n tags options state)
                :tag-opened-at              (interpreter.metafunctions/tag-opened-at-f             n tags options state)
                :tag-opened?                (interpreter.metafunctions/tag-opened-f                n tags options state)
                :tag-opening-pattern        (interpreter.metafunctions/tag-opening-pattern-f       n tags options state)
                :tag-opens?                 (interpreter.metafunctions/tag-opens-f                 n tags options state)
                :tag-options                (interpreter.metafunctions/tag-options-f               n tags options state)
                :tag-parent?                (interpreter.metafunctions/tag-parent-f                n tags options state)
                :tag-started-at             (interpreter.metafunctions/tag-started-at-f            n tags options state)
                :tag-started?               (interpreter.metafunctions/tag-started-f               n tags options state)
                :tag-starts?                (interpreter.metafunctions/tag-starts-f                n tags options state)
                :use-metadata               (interpreter.metafunctions/use-metadata-f              n tags options state)})

           (f1 [state]
               (if (interpreter.utils/offset-reached? n tags options state)
                   (fn [result state metafunctions] (try (f result state metafunctions)
                                                         (catch Exception e (println e))))
                   (fn [result _ _] (-&gt; result))))]

          (let [initial-state {:actual-tags [] :left-tags {} :cursor 0 :result initial}]
               (loop [{:keys [result] :as state} initial-state]
                     (let [actual-state           (interpreter.utils/update-previous-state n tags options state)
                           provided-state         (interpreter.utils/filter-provided-state n tags options actual-state)
                           provided-metafunctions (-&gt; actual-state f0)
                           applied-function       (-&gt; actual-state f1)
                           updated-result         (-&gt; result (applied-function provided-state provided-metafunctions))
                           updated-state          (interpreter.utils/update-actual-state n tags options actual-state updated-result)]
                          (cond (interpreter.utils/iteration-stopped? n tags options updated-state) (-&gt; updated-state :result)
                                (interpreter.utils/endpoint-reached?  n tags options updated-state) (-&gt; updated-state :result)
                                (interpreter.utils/iteration-ended?   n tags options updated-state) (-&gt; updated-state :result)
                                :next-iteration (let [prepared-state (interpreter.utils/prepare-next-state n tags options updated-state)]
                                                     (recur prepared-state)))))))))</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qad89da83-f22e-49b0-b302-1dfc6386b4a9"><div class="content-block--header"><pre class="color--soft-grey text--xs">description</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed text--wrap">- Applies the given 'f' function at each cursor position of the given 'n' string.<br>- Provides a state of the actual position and a set of metafunctions for the applied function.<br>- The provided state contains the 'actual-tags' vector that describes the opened tags at the actual position<br>  and contains the 'left-tags' map that contains tags that are already ended before the actual position and<br>  removed from the 'actual-tags' vector.</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q9bf19e65-8605-4ab0-85c9-b2fd56e18a95"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "My string" (fn [result state metafunctions]) nil)</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q14105364-04cc-4a97-be4c-a3d0ea4a21a7"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(interpreter "My string" println nil)</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="qb18336be-7984-4448-bf3d-79a327c9e626"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(let [my-text     "abc(def(ghi))"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:paren #"\(" #"\)"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :paren :started-at 3 :opened-at 4}<br>               {:name :paren :started-at 7 :opened-at 8}]<br> :cursor 8}</pre></div></div><div class="content-block" data-collapsed="false" data-collapsible="false" id="q49f4540f-6973-46f0-b121-729134c84c2c"><div class="content-block--header"><pre class="color--soft-grey text--xs">usage</pre></div><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">(let [my-text     "&lt;div&gt;Hello World!&lt;/div&gt;"<br>      my-function (fn [result state _] (if (= 8 (:cursor state)) state result)<br>      my-initial  nil<br>      my-tags     [[:div #"\&lt;div\&gt;" #"\&lt;\/div\&gt;"]]<br>    (interpreter my-text my-function my-initial my-tags)<br>=&gt;<br>{:actual-tags [{:name :div :started-at 0 :opened-at 5}]<br> :cursor 8}</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="false" id="qaccc2f1a-7609-4189-8232-fe975e71f6f1"><div class="content-block--header"><pre class="color--soft-grey text--xs">param</pre><pre class="color--soft-grey text--xs">string</pre><pre class="color--hard-grey text--xs text--bold">n</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="true" id="qc701e5f0-f8af-4b37-990f-fecc76eeddaa"><button class="content-block--header" onClick="toggleCollapsible(&apos;qc701e5f0-f8af-4b37-990f-fecc76eeddaa&apos;)"><pre class="color--soft-grey text--xs">param</pre><pre class="color--soft-grey text--xs">function</pre><pre class="color--hard-grey text--xs text--bold">f</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">Applied at each cursor position.<br>Takes the output of the previous iteration (or the given 'initial' value) as first parameter.<br>Takes the state of the actual cursor position as second parameter.<br>Takes a map with metafunctions as third parameter.</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="false" id="q3eea0042-de40-4edc-a8d8-8d8624b582c6"><div class="content-block--header"><pre class="color--soft-grey text--xs">param</pre><pre class="color--soft-grey text--xs">*</pre><pre class="color--hard-grey text--xs text--bold">initial</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="true" id="q9b3ae82c-6017-49a8-bd6c-174b4e44a483"><button class="content-block--header" onClick="toggleCollapsible(&apos;q9b3ae82c-6017-49a8-bd6c-174b4e44a483&apos;)"><pre class="color--soft-grey text--xs">param</pre><pre class="color--soft-grey text--xs">vectors in vector</pre><pre class="color--soft-grey text--xs">opt</pre><pre class="color--hard-grey text--xs text--bold">tags</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">[[(keyword) tag-name<br>  (regex pattern) pattern / opening-pattern<br>  (regex pattern)(opt) closing-pattern<br>  (map)(opt) options<br>  {:accepted-ancestors (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted ancestor tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no ancestor tags.<br>   :accepted-children (keywords in vector or empty vector)(opt)<br>    Processes child tags only if listed in this vector.<br>    Leave this vector empty for void tags that cannot have children.<br>   :accepted-descendants (keywords in vector or empty vector)(opt)<br>    Processes descendant tags only if listed in this vector.<br>    Leave this vector empty for void tags that cannot have descendants.<br>   :accepted-parents (keywords in vector or empty vector)(opt)<br>    Processes the tag only if at least one of the accepted parent tags is opened.<br>    Leave this vector empty for tags that are processed only if they have no parent tags.<br>   :pattern-limits (map)(opt)<br>    Limited pattern lookaround and match lengths help decrease the processing time<br>    and help create more accurate matches for tag patterns with lookaround assertions.<br>    {:lookahead (integer)(opt)<br>      Default: 0<br>     :lookbehind (integer)(opt)<br>      Default: 0<br>     :match (integer)(opt)<br>      Default: 64<br>     :closing/lookahead (integer)(opt)<br>      Default: 0<br>     :closing/lookbehind (integer)(opt)<br>      Default: 0<br>     :closing/match (integer)(opt)<br>      Default: 64<br>     :opening/lookahead (integer)(opt)<br>      Default: 0<br>     :opening/lookbehind (integer)(opt)<br>      Default: 0<br>     :opening/match (integer)(opt)<br>      Default: 64}]]</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="true" id="qa2aa07b0-68b1-41d0-93c8-74793187ceda"><button class="content-block--header" onClick="toggleCollapsible(&apos;qa2aa07b0-68b1-41d0-93c8-74793187ceda&apos;)"><pre class="color--soft-grey text--xs">param</pre><pre class="color--soft-grey text--xs">map</pre><pre class="color--soft-grey text--xs">opt</pre><pre class="color--hard-grey text--xs text--bold">options</pre></button><div class="content-block--text"><pre class="color--hard-grey text--s text--boxed scroll-x">{:endpoint (integer)(opt)<br>  Stops the interpreter at the given 'endpoint' position.<br> :offset (integer)(opt)<br>  Starts applying the given 'f' function at the given 'offset' position.<br>  In order to make accurate tag map, the interpreter starts processing at the 0th position even if the 'offset' value is higher than 0.}</pre></div></div><div class="content-block" data-collapsed="true" data-collapsible="false" id="q6c1a08eb-eb1e-4320-979a-c9f955c415e1"><div class="content-block--header"><pre class="color--soft-grey text--xs">return</pre><pre class="color--soft-grey text--xs">*</pre></div></div></div></div></div><div id="top-bar"><pre class="text--xl text--bold" id="top-bar--library-name">cljc-syntax-interpreter</pre><pre class="color--soft-grey text--s" id="top-bar--library-version">0.0.7.0</pre><a class="text--s" href="https://github.com/mt-devtools/cljc-syntax-interpreter" id="top-bar--library-uri"><pre class="color--hard-blue">github.com/mt-devtools/cljc-syntax-interpreter</pre></a></div><div id="bottom-bar"><a class="color--soft-purple text--s" href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>
